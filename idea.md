### 第二部分：综合最佳推荐

**🏆 推荐方案：自适应大邻域搜索 (ALNS) + 序列依赖极点装箱法 (Sequence-Dependent Extreme Point Heuristic)**

**理由**：

1. **完美契合模型假设(7)**：模型要求“先拜访的取货点货物装在更内侧”。ALNS 的路径构建过程天然就是序列化的，配合“序列装箱”，我们在装载第  站的货物时，第  到  站的货物已经是固定障碍物，天然满足顺序约束。
2. **处理保税仓约束**：保税仓作为“必须第一站”的硬约束，在 ALNS 的 `Repair` 算子中只需加一行判定即可严格遵守，而 GA 或 ACO 处理起来会很别扭。
3. **多车型适配**：ALNS 可以在插入节点导致当前车型装不下时，动态尝试“升级”车型（如从 4.2m 换到 7.6m），这对于优化 （装载率）至关重要。

---

### 第三部分：详细设计方案 (ALNS + EP)

这份方案包含了核心数据结构、算法流程和关键优化点，可作为开发的技术规格书。

#### 1. 系统架构

系统分为 **Master (路由层)** 和 **Slave (装箱层)**。

* **输入**：订单集合 、车型集合 、距离矩阵 。
* **目标**：最小化 。

#### 2. 核心模块一：三维装箱检测器 (The Packer)

这是算法的“心脏”。为了满足空间利用率和支撑约束，推荐使用 **极点法 (Extreme Point Heuristic)** 的变种。

* **输入**：按路径访问顺序排序的货物列表 ，及指定车型。
* **坐标系**：车厢深处（靠车头）为 。
* **逻辑流程**：
1. **初始化**：极点集合 ，已装货物 。
2. **按站点循环**：依次处理 Stop 1, Stop 2... 的货物。
* *注意：当前站点装载时，之前站点的货物视为不可移动的障碍物。*


3. **货物装载 (Best Fit)**：对当前站点的每个货物 ：
* 遍历所有  点，尝试 6 种旋转方向。
* **可行性检查**：
1. **边界**：不超出车厢。
2. **不重叠**：与  中所有货物不冲突。
3. **支撑约束 (式2-47)**：计算货物底面与下方物体（其他货物或车底）的接触面积。若 ，则非法。
4. **顺序约束**：由于我们是按顺序装载，且优先填入  较小的位置，天然满足“后来的货在外侧”。


* **打分选择**：在所有合法位置中，优先选择  最小（最靠里）、 最小（最靠下）的位置。
* **更新**：放置货物，更新  集合（移除被覆盖的，生成新的极点）。


4. **返回**：如果所有货物成功装入，返回 `True` 及坐标；否则返回 `False`。



#### 3. 核心模块二：ALNS 主逻辑

* **Step 1: 构造初始解**
* 使用 **贪婪插入策略**。随机选一辆车，不断找“距离最近且能装得下”的下一个点。
* *保税仓逻辑*：如果选中的点是保税仓，强制设为该路径的第 1 个点（Depot 之后）。


* **Step 2: ALNS 迭代 (主循环)**
* **破坏算子 (Destroy)**：
* `Random Removal`: 随机移除  个点。
* `Worst Cost Removal`: 移除导致目标函数值增加最多的点（通常是又远又大的货）。
* `Shaw Removal`: 移除一组“相关”的点（距离近、货物尺寸相似）。


* **修复算子 (Repair)**：
* `Greedy Insertion`: 遍历所有未分配点，尝试插入到所有可能位置，选 Cost 增量最小的。
* **关键判定**：如果点是保税仓，仅尝试 `Index=1` 的位置。
* **多车型选择**：插入时，先试小车型，装不下试大车型。


* `Regret-2 Insertion`: 优先修复那些“现在不插，以后插代价很大”的点。


* **接受准则**：使用模拟退火 (Simulated Annealing) 机制接受劣解，避免陷入局部最优。



#### 4. 关键优化技术 (针对大规模求解)

1. **装箱缓存 (Caching)**：
* **原理**：ALNS 会反复评估相同的路径片段（例如 `A->B->C`）。
* **实现**：建立哈希表 `Map<Hash(RouteSequence), PackResult>`。
* **效果**：可减少 90% 以上的重复装箱计算。


2. **一维剪枝 (1D Pruning)**：
* 在调用 3D 算法前，先检查 `Sum(Volume) > TruckVolume` 或 `Sum(Weight) > TruckCapacity`。如果一维都不满足，直接返回不可行。


3. **支撑面积快速计算**：
* 不要用复杂的几何求交算法。可以将车厢底面离散化为网格（例如  的 Grid），维护一个 `HeightMap[x][y]`。计算支撑时，只需查询网格区域的高度是否一致。



#### 5. 目标函数归一化

公式：

*  (空载率) 范围是 0~1。
*  (距离) 可能是几百几千。
* **建议**：在代码中对  进行归一化（例如除以初始解的总距离），或者设置 ，确保两个目标在一个数量级，否则算法会忽略装载率优化。

### 四、 开发检查清单 (Checklist)

在您后续的编程实施中，请重点检查以下几点：

1. **坐标系定义**：确保装箱算法的  轴定义与题目图 2-1 一致。
2. **保税仓硬约束**：在生成初始解和 Repair 阶段，必须有 `if is_bonded and index != 1: continue` 的逻辑。
3. **不可移动约束**：代码逻辑中，在装载第  站货物时，第  站的货物坐标绝对不能变。